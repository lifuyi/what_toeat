# 配料搜索API前端集成指南

## 🎯 API接口概览

### 1. 专门配料搜索接口（推荐）
```
GET /api/recipes/ingredients
```

### 2. 改进的通用搜索接口
```
GET /api/recipes
```

## 📱 前端集成方案

### 方案一：智能搜索组件

```javascript
// 配料搜索组件
class IngredientSearch {
  constructor(apiBaseUrl = 'http://localhost:3001') {
    this.apiBaseUrl = apiBaseUrl;
  }

  // 智能搜索：自动判断搜索模式
  async smartSearch(query, options = {}) {
    const {
      mode = 'auto',  // 'auto', 'and', 'or'
      limit = 12,
      showMatchDetails = true
    } = options;

    // 自动判断搜索模式
    const ingredients = query.trim().split(/\s+/);
    let searchMode = mode;
    
    if (mode === 'auto') {
      // 1个配料用OR模式（更多结果）
      // 2个以上配料用AND模式（更精确）
      searchMode = ingredients.length === 1 ? 'or' : 'and';
    }

    const endpoint = showMatchDetails 
      ? '/api/recipes/ingredients' 
      : '/api/recipes';

    const params = new URLSearchParams({
      query: query,
      [showMatchDetails ? 'mode' : 'ingredient_mode']: searchMode,
      limit: limit.toString()
    });

    if (!showMatchDetails) {
      params.append('fields', 'yl');
    }

    try {
      const response = await fetch(`${this.apiBaseUrl}${endpoint}?${params}`);
      const data = await response.json();
      
      return {
        success: true,
        data: data,
        searchMode: searchMode,
        ingredients: ingredients
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // 精确搜索：必须包含所有配料
  async exactSearch(ingredients, limit = 12) {
    return this.smartSearch(ingredients, { mode: 'and', limit });
  }

  // 广泛搜索：包含任一配料即可
  async broadSearch(ingredients, limit = 12) {
    return this.smartSearch(ingredients, { mode: 'or', limit });
  }
}
```

### 方案二：React Hook

```javascript
// useIngredientSearch.js
import { useState, useCallback, useMemo } from 'react';

export const useIngredientSearch = (apiBaseUrl = 'http://localhost:3001') => {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [searchInfo, setSearchInfo] = useState(null);

  const search = useCallback(async (query, options = {}) => {
    if (!query.trim()) {
      setResults([]);
      setSearchInfo(null);
      return;
    }

    setLoading(true);
    setError(null);

    const {
      mode = 'auto',
      limit = 12,
      showMatchDetails = true
    } = options;

    const ingredients = query.trim().split(/\s+/);
    let searchMode = mode === 'auto' 
      ? (ingredients.length === 1 ? 'or' : 'and')
      : mode;

    const endpoint = showMatchDetails 
      ? '/api/recipes/ingredients' 
      : '/api/recipes';

    const params = new URLSearchParams({
      query: query,
      [showMatchDetails ? 'mode' : 'ingredient_mode']: searchMode,
      limit: limit.toString()
    });

    if (!showMatchDetails) {
      params.append('fields', 'yl');
    }

    try {
      const response = await fetch(`${apiBaseUrl}${endpoint}?${params}`);
      const data = await response.json();
      
      if (showMatchDetails) {
        setResults(data.results || []);
        setSearchInfo({
          query: data.query,
          ingredients: data.ingredients,
          mode: data.mode,
          total: data.total,
          searchTime: data.searchTime
        });
      } else {
        setResults(data || []);
        setSearchInfo({
          query: query,
          ingredients: ingredients,
          mode: searchMode,
          total: data.length
        });
      }
    } catch (err) {
      setError(err.message);
      setResults([]);
      setSearchInfo(null);
    } finally {
      setLoading(false);
    }
  }, [apiBaseUrl]);

  // 搜索建议
  const searchSuggestions = useMemo(() => {
    if (!searchInfo) return null;
    
    const { ingredients, mode, total } = searchInfo;
    
    return {
      currentMode: mode,
      alternativeMode: mode === 'and' ? 'or' : 'and',
      suggestion: total === 0 
        ? `尝试${mode === 'and' ? 'OR' : 'AND'}模式搜索`
        : total < 5 && mode === 'and'
        ? '结果较少，可尝试OR模式获取更多结果'
        : null
    };
  }, [searchInfo]);

  return {
    results,
    loading,
    error,
    searchInfo,
    searchSuggestions,
    search
  };
};
```

### 方案三：Vue Composition API

```javascript
// useIngredientSearch.js
import { ref, computed } from 'vue';

export function useIngredientSearch(apiBaseUrl = 'http://localhost:3001') {
  const results = ref([]);
  const loading = ref(false);
  const error = ref(null);
  const searchInfo = ref(null);

  const search = async (query, options = {}) => {
    if (!query.trim()) {
      results.value = [];
      searchInfo.value = null;
      return;
    }

    loading.value = true;
    error.value = null;

    const {
      mode = 'auto',
      limit = 12,
      showMatchDetails = true
    } = options;

    const ingredients = query.trim().split(/\s+/);
    let searchMode = mode === 'auto' 
      ? (ingredients.length === 1 ? 'or' : 'and')
      : mode;

    const endpoint = showMatchDetails 
      ? '/api/recipes/ingredients' 
      : '/api/recipes';

    const params = new URLSearchParams({
      query: query,
      [showMatchDetails ? 'mode' : 'ingredient_mode']: searchMode,
      limit: limit.toString()
    });

    if (!showMatchDetails) {
      params.append('fields', 'yl');
    }

    try {
      const response = await fetch(`${apiBaseUrl}${endpoint}?${params}`);
      const data = await response.json();
      
      if (showMatchDetails) {
        results.value = data.results || [];
        searchInfo.value = {
          query: data.query,
          ingredients: data.ingredients,
          mode: data.mode,
          total: data.total,
          searchTime: data.searchTime
        };
      } else {
        results.value = data || [];
        searchInfo.value = {
          query: query,
          ingredients: ingredients,
          mode: searchMode,
          total: data.length
        };
      }
    } catch (err) {
      error.value = err.message;
      results.value = [];
      searchInfo.value = null;
    } finally {
      loading.value = false;
    }
  };

  const searchSuggestions = computed(() => {
    if (!searchInfo.value) return null;
    
    const { ingredients, mode, total } = searchInfo.value;
    
    return {
      currentMode: mode,
      alternativeMode: mode === 'and' ? 'or' : 'and',
      suggestion: total === 0 
        ? `尝试${mode === 'and' ? 'OR' : 'AND'}模式搜索`
        : total < 5 && mode === 'and'
        ? '结果较少，可尝试OR模式获取更多结果'
        : null
    };
  });

  return {
    results,
    loading,
    error,
    searchInfo,
    searchSuggestions,
    search
  };
}
```

## 🎨 UI组件示例

### React搜索组件

```jsx
// IngredientSearchComponent.jsx
import React, { useState, useEffect } from 'react';
import { useIngredientSearch } from './useIngredientSearch';

const IngredientSearchComponent = () => {
  const [query, setQuery] = useState('');
  const [searchMode, setSearchMode] = useState('auto');
  const { 
    results, 
    loading, 
    error, 
    searchInfo, 
    searchSuggestions, 
    search 
  } = useIngredientSearch();

  // 防抖搜索
  useEffect(() => {
    const timer = setTimeout(() => {
      if (query.trim()) {
        search(query, { mode: searchMode });
      }
    }, 300);

    return () => clearTimeout(timer);
  }, [query, searchMode, search]);

  return (
    <div className="ingredient-search">
      {/* 搜索输入框 */}
      <div className="search-input">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="输入配料，如：黄瓜 辣椒"
          className="search-field"
        />
        
        {/* 搜索模式选择 */}
        <select 
          value={searchMode} 
          onChange={(e) => setSearchMode(e.target.value)}
          className="mode-selector"
        >
          <option value="auto">智能模式</option>
          <option value="and">精确搜索(AND)</option>
          <option value="or">广泛搜索(OR)</option>
        </select>
      </div>

      {/* 搜索信息 */}
      {searchInfo && (
        <div className="search-info">
          <span>搜索: {searchInfo.query}</span>
          <span>模式: {searchInfo.mode.toUpperCase()}</span>
          <span>结果: {searchInfo.total}条</span>
          {searchInfo.searchTime && (
            <span>耗时: {searchInfo.searchTime}</span>
          )}
        </div>
      )}

      {/* 搜索建议 */}
      {searchSuggestions?.suggestion && (
        <div className="search-suggestion">
          💡 {searchSuggestions.suggestion}
          <button 
            onClick={() => setSearchMode(searchSuggestions.alternativeMode)}
            className="suggestion-btn"
          >
            切换到{searchSuggestions.alternativeMode.toUpperCase()}模式
          </button>
        </div>
      )}

      {/* 加载状态 */}
      {loading && <div className="loading">搜索中...</div>}

      {/* 错误信息 */}
      {error && <div className="error">搜索失败: {error}</div>}

      {/* 搜索结果 */}
      <div className="results">
        {results.map((recipe, index) => (
          <div key={recipe.id || index} className="recipe-card">
            <h3>{recipe.title}</h3>
            
            {/* 匹配信息（仅专门接口返回） */}
            {recipe.matchScore !== undefined && (
              <div className="match-info">
                <div className="match-score">
                  匹配度: {recipe.matchPercentage}% 
                  ({recipe.matchScore}/{recipe.totalIngredients})
                </div>
                <div className="matched-ingredients">
                  匹配配料: {recipe.matchedIngredients?.join(', ')}
                </div>
              </div>
            )}
            
            <div className="recipe-details">
              <span>评分: {recipe.grade || 'N/A'}</span>
              <span>难度: {recipe.difficulty || 'N/A'}</span>
              <span>用时: {recipe.costtime || 'N/A'}</span>
            </div>
            
            {recipe.yl && (
              <div className="ingredients">
                配料: {recipe.yl.replace(/#/g, ', ')}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
};

export default IngredientSearchComponent;
```

## 📱 移动端优化

```javascript
// 移动端搜索优化
class MobileIngredientSearch {
  constructor(apiBaseUrl) {
    this.apiBaseUrl = apiBaseUrl;
    this.searchCache = new Map();
    this.abortController = null;
  }

  // 带缓存的搜索
  async searchWithCache(query, options = {}) {
    const cacheKey = `${query}-${JSON.stringify(options)}`;
    
    if (this.searchCache.has(cacheKey)) {
      return this.searchCache.get(cacheKey);
    }

    // 取消之前的请求
    if (this.abortController) {
      this.abortController.abort();
    }
    
    this.abortController = new AbortController();
    
    try {
      const result = await this.search(query, {
        ...options,
        signal: this.abortController.signal
      });
      
      // 缓存结果（最多缓存50个）
      if (this.searchCache.size >= 50) {
        const firstKey = this.searchCache.keys().next().value;
        this.searchCache.delete(firstKey);
      }
      this.searchCache.set(cacheKey, result);
      
      return result;
    } catch (error) {
      if (error.name === 'AbortError') {
        return { success: false, aborted: true };
      }
      throw error;
    }
  }

  // 搜索历史管理
  saveSearchHistory(query) {
    const history = JSON.parse(localStorage.getItem('searchHistory') || '[]');
    const newHistory = [query, ...history.filter(h => h !== query)].slice(0, 10);
    localStorage.setItem('searchHistory', JSON.stringify(newHistory));
  }

  getSearchHistory() {
    return JSON.parse(localStorage.getItem('searchHistory') || '[]');
  }
}
```

## 🎯 最佳实践建议

### 1. 用户体验优化
- **防抖搜索**: 300ms延迟，避免频繁请求
- **智能模式**: 1个配料用OR，多个配料用AND
- **搜索建议**: 无结果时提示切换模式
- **加载状态**: 显示搜索进度和耗时

### 2. 性能优化
- **请求缓存**: 缓存常用搜索结果
- **请求取消**: 避免重复请求
- **分页加载**: 大量结果时分页显示

### 3. 移动端适配
- **触摸优化**: 大按钮，易点击
- **网络优化**: 请求压缩，离线缓存
- **响应式设计**: 适配不同屏幕尺寸

现在您可以选择：

1. **创建完整的前端示例** - 我可以帮您创建一个完整的HTML+JS演示页面
2. **特定框架集成** - 针对您使用的具体前端框架（React/Vue/Angular等）提供详细代码
3. **移动端App集成** - 如果是移动应用，我可以提供React Native或Flutter的集成方案
4. **API文档完善** - 创建详细的API文档供前端团队使用

您希望我重点帮您实现哪个方面呢？