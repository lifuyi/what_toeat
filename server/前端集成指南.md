# é…æ–™æœç´¢APIå‰ç«¯é›†æˆæŒ‡å—

## ğŸ¯ APIæ¥å£æ¦‚è§ˆ

### 1. ä¸“é—¨é…æ–™æœç´¢æ¥å£ï¼ˆæ¨èï¼‰
```
GET /api/recipes/ingredients
```

### 2. æ”¹è¿›çš„é€šç”¨æœç´¢æ¥å£
```
GET /api/recipes
```

## ğŸ“± å‰ç«¯é›†æˆæ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šæ™ºèƒ½æœç´¢ç»„ä»¶

```javascript
// é…æ–™æœç´¢ç»„ä»¶
class IngredientSearch {
  constructor(apiBaseUrl = 'http://localhost:3001') {
    this.apiBaseUrl = apiBaseUrl;
  }

  // æ™ºèƒ½æœç´¢ï¼šè‡ªåŠ¨åˆ¤æ–­æœç´¢æ¨¡å¼
  async smartSearch(query, options = {}) {
    const {
      mode = 'auto',  // 'auto', 'and', 'or'
      limit = 12,
      showMatchDetails = true
    } = options;

    // è‡ªåŠ¨åˆ¤æ–­æœç´¢æ¨¡å¼
    const ingredients = query.trim().split(/\s+/);
    let searchMode = mode;
    
    if (mode === 'auto') {
      // 1ä¸ªé…æ–™ç”¨ORæ¨¡å¼ï¼ˆæ›´å¤šç»“æœï¼‰
      // 2ä¸ªä»¥ä¸Šé…æ–™ç”¨ANDæ¨¡å¼ï¼ˆæ›´ç²¾ç¡®ï¼‰
      searchMode = ingredients.length === 1 ? 'or' : 'and';
    }

    const endpoint = showMatchDetails 
      ? '/api/recipes/ingredients' 
      : '/api/recipes';

    const params = new URLSearchParams({
      query: query,
      [showMatchDetails ? 'mode' : 'ingredient_mode']: searchMode,
      limit: limit.toString()
    });

    if (!showMatchDetails) {
      params.append('fields', 'yl');
    }

    try {
      const response = await fetch(`${this.apiBaseUrl}${endpoint}?${params}`);
      const data = await response.json();
      
      return {
        success: true,
        data: data,
        searchMode: searchMode,
        ingredients: ingredients
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // ç²¾ç¡®æœç´¢ï¼šå¿…é¡»åŒ…å«æ‰€æœ‰é…æ–™
  async exactSearch(ingredients, limit = 12) {
    return this.smartSearch(ingredients, { mode: 'and', limit });
  }

  // å¹¿æ³›æœç´¢ï¼šåŒ…å«ä»»ä¸€é…æ–™å³å¯
  async broadSearch(ingredients, limit = 12) {
    return this.smartSearch(ingredients, { mode: 'or', limit });
  }
}
```

### æ–¹æ¡ˆäºŒï¼šReact Hook

```javascript
// useIngredientSearch.js
import { useState, useCallback, useMemo } from 'react';

export const useIngredientSearch = (apiBaseUrl = 'http://localhost:3001') => {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [searchInfo, setSearchInfo] = useState(null);

  const search = useCallback(async (query, options = {}) => {
    if (!query.trim()) {
      setResults([]);
      setSearchInfo(null);
      return;
    }

    setLoading(true);
    setError(null);

    const {
      mode = 'auto',
      limit = 12,
      showMatchDetails = true
    } = options;

    const ingredients = query.trim().split(/\s+/);
    let searchMode = mode === 'auto' 
      ? (ingredients.length === 1 ? 'or' : 'and')
      : mode;

    const endpoint = showMatchDetails 
      ? '/api/recipes/ingredients' 
      : '/api/recipes';

    const params = new URLSearchParams({
      query: query,
      [showMatchDetails ? 'mode' : 'ingredient_mode']: searchMode,
      limit: limit.toString()
    });

    if (!showMatchDetails) {
      params.append('fields', 'yl');
    }

    try {
      const response = await fetch(`${apiBaseUrl}${endpoint}?${params}`);
      const data = await response.json();
      
      if (showMatchDetails) {
        setResults(data.results || []);
        setSearchInfo({
          query: data.query,
          ingredients: data.ingredients,
          mode: data.mode,
          total: data.total,
          searchTime: data.searchTime
        });
      } else {
        setResults(data || []);
        setSearchInfo({
          query: query,
          ingredients: ingredients,
          mode: searchMode,
          total: data.length
        });
      }
    } catch (err) {
      setError(err.message);
      setResults([]);
      setSearchInfo(null);
    } finally {
      setLoading(false);
    }
  }, [apiBaseUrl]);

  // æœç´¢å»ºè®®
  const searchSuggestions = useMemo(() => {
    if (!searchInfo) return null;
    
    const { ingredients, mode, total } = searchInfo;
    
    return {
      currentMode: mode,
      alternativeMode: mode === 'and' ? 'or' : 'and',
      suggestion: total === 0 
        ? `å°è¯•${mode === 'and' ? 'OR' : 'AND'}æ¨¡å¼æœç´¢`
        : total < 5 && mode === 'and'
        ? 'ç»“æœè¾ƒå°‘ï¼Œå¯å°è¯•ORæ¨¡å¼è·å–æ›´å¤šç»“æœ'
        : null
    };
  }, [searchInfo]);

  return {
    results,
    loading,
    error,
    searchInfo,
    searchSuggestions,
    search
  };
};
```

### æ–¹æ¡ˆä¸‰ï¼šVue Composition API

```javascript
// useIngredientSearch.js
import { ref, computed } from 'vue';

export function useIngredientSearch(apiBaseUrl = 'http://localhost:3001') {
  const results = ref([]);
  const loading = ref(false);
  const error = ref(null);
  const searchInfo = ref(null);

  const search = async (query, options = {}) => {
    if (!query.trim()) {
      results.value = [];
      searchInfo.value = null;
      return;
    }

    loading.value = true;
    error.value = null;

    const {
      mode = 'auto',
      limit = 12,
      showMatchDetails = true
    } = options;

    const ingredients = query.trim().split(/\s+/);
    let searchMode = mode === 'auto' 
      ? (ingredients.length === 1 ? 'or' : 'and')
      : mode;

    const endpoint = showMatchDetails 
      ? '/api/recipes/ingredients' 
      : '/api/recipes';

    const params = new URLSearchParams({
      query: query,
      [showMatchDetails ? 'mode' : 'ingredient_mode']: searchMode,
      limit: limit.toString()
    });

    if (!showMatchDetails) {
      params.append('fields', 'yl');
    }

    try {
      const response = await fetch(`${apiBaseUrl}${endpoint}?${params}`);
      const data = await response.json();
      
      if (showMatchDetails) {
        results.value = data.results || [];
        searchInfo.value = {
          query: data.query,
          ingredients: data.ingredients,
          mode: data.mode,
          total: data.total,
          searchTime: data.searchTime
        };
      } else {
        results.value = data || [];
        searchInfo.value = {
          query: query,
          ingredients: ingredients,
          mode: searchMode,
          total: data.length
        };
      }
    } catch (err) {
      error.value = err.message;
      results.value = [];
      searchInfo.value = null;
    } finally {
      loading.value = false;
    }
  };

  const searchSuggestions = computed(() => {
    if (!searchInfo.value) return null;
    
    const { ingredients, mode, total } = searchInfo.value;
    
    return {
      currentMode: mode,
      alternativeMode: mode === 'and' ? 'or' : 'and',
      suggestion: total === 0 
        ? `å°è¯•${mode === 'and' ? 'OR' : 'AND'}æ¨¡å¼æœç´¢`
        : total < 5 && mode === 'and'
        ? 'ç»“æœè¾ƒå°‘ï¼Œå¯å°è¯•ORæ¨¡å¼è·å–æ›´å¤šç»“æœ'
        : null
    };
  });

  return {
    results,
    loading,
    error,
    searchInfo,
    searchSuggestions,
    search
  };
}
```

## ğŸ¨ UIç»„ä»¶ç¤ºä¾‹

### Reactæœç´¢ç»„ä»¶

```jsx
// IngredientSearchComponent.jsx
import React, { useState, useEffect } from 'react';
import { useIngredientSearch } from './useIngredientSearch';

const IngredientSearchComponent = () => {
  const [query, setQuery] = useState('');
  const [searchMode, setSearchMode] = useState('auto');
  const { 
    results, 
    loading, 
    error, 
    searchInfo, 
    searchSuggestions, 
    search 
  } = useIngredientSearch();

  // é˜²æŠ–æœç´¢
  useEffect(() => {
    const timer = setTimeout(() => {
      if (query.trim()) {
        search(query, { mode: searchMode });
      }
    }, 300);

    return () => clearTimeout(timer);
  }, [query, searchMode, search]);

  return (
    <div className="ingredient-search">
      {/* æœç´¢è¾“å…¥æ¡† */}
      <div className="search-input">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="è¾“å…¥é…æ–™ï¼Œå¦‚ï¼šé»„ç“œ è¾£æ¤’"
          className="search-field"
        />
        
        {/* æœç´¢æ¨¡å¼é€‰æ‹© */}
        <select 
          value={searchMode} 
          onChange={(e) => setSearchMode(e.target.value)}
          className="mode-selector"
        >
          <option value="auto">æ™ºèƒ½æ¨¡å¼</option>
          <option value="and">ç²¾ç¡®æœç´¢(AND)</option>
          <option value="or">å¹¿æ³›æœç´¢(OR)</option>
        </select>
      </div>

      {/* æœç´¢ä¿¡æ¯ */}
      {searchInfo && (
        <div className="search-info">
          <span>æœç´¢: {searchInfo.query}</span>
          <span>æ¨¡å¼: {searchInfo.mode.toUpperCase()}</span>
          <span>ç»“æœ: {searchInfo.total}æ¡</span>
          {searchInfo.searchTime && (
            <span>è€—æ—¶: {searchInfo.searchTime}</span>
          )}
        </div>
      )}

      {/* æœç´¢å»ºè®® */}
      {searchSuggestions?.suggestion && (
        <div className="search-suggestion">
          ğŸ’¡ {searchSuggestions.suggestion}
          <button 
            onClick={() => setSearchMode(searchSuggestions.alternativeMode)}
            className="suggestion-btn"
          >
            åˆ‡æ¢åˆ°{searchSuggestions.alternativeMode.toUpperCase()}æ¨¡å¼
          </button>
        </div>
      )}

      {/* åŠ è½½çŠ¶æ€ */}
      {loading && <div className="loading">æœç´¢ä¸­...</div>}

      {/* é”™è¯¯ä¿¡æ¯ */}
      {error && <div className="error">æœç´¢å¤±è´¥: {error}</div>}

      {/* æœç´¢ç»“æœ */}
      <div className="results">
        {results.map((recipe, index) => (
          <div key={recipe.id || index} className="recipe-card">
            <h3>{recipe.title}</h3>
            
            {/* åŒ¹é…ä¿¡æ¯ï¼ˆä»…ä¸“é—¨æ¥å£è¿”å›ï¼‰ */}
            {recipe.matchScore !== undefined && (
              <div className="match-info">
                <div className="match-score">
                  åŒ¹é…åº¦: {recipe.matchPercentage}% 
                  ({recipe.matchScore}/{recipe.totalIngredients})
                </div>
                <div className="matched-ingredients">
                  åŒ¹é…é…æ–™: {recipe.matchedIngredients?.join(', ')}
                </div>
              </div>
            )}
            
            <div className="recipe-details">
              <span>è¯„åˆ†: {recipe.grade || 'N/A'}</span>
              <span>éš¾åº¦: {recipe.difficulty || 'N/A'}</span>
              <span>ç”¨æ—¶: {recipe.costtime || 'N/A'}</span>
            </div>
            
            {recipe.yl && (
              <div className="ingredients">
                é…æ–™: {recipe.yl.replace(/#/g, ', ')}
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
};

export default IngredientSearchComponent;
```

## ğŸ“± ç§»åŠ¨ç«¯ä¼˜åŒ–

```javascript
// ç§»åŠ¨ç«¯æœç´¢ä¼˜åŒ–
class MobileIngredientSearch {
  constructor(apiBaseUrl) {
    this.apiBaseUrl = apiBaseUrl;
    this.searchCache = new Map();
    this.abortController = null;
  }

  // å¸¦ç¼“å­˜çš„æœç´¢
  async searchWithCache(query, options = {}) {
    const cacheKey = `${query}-${JSON.stringify(options)}`;
    
    if (this.searchCache.has(cacheKey)) {
      return this.searchCache.get(cacheKey);
    }

    // å–æ¶ˆä¹‹å‰çš„è¯·æ±‚
    if (this.abortController) {
      this.abortController.abort();
    }
    
    this.abortController = new AbortController();
    
    try {
      const result = await this.search(query, {
        ...options,
        signal: this.abortController.signal
      });
      
      // ç¼“å­˜ç»“æœï¼ˆæœ€å¤šç¼“å­˜50ä¸ªï¼‰
      if (this.searchCache.size >= 50) {
        const firstKey = this.searchCache.keys().next().value;
        this.searchCache.delete(firstKey);
      }
      this.searchCache.set(cacheKey, result);
      
      return result;
    } catch (error) {
      if (error.name === 'AbortError') {
        return { success: false, aborted: true };
      }
      throw error;
    }
  }

  // æœç´¢å†å²ç®¡ç†
  saveSearchHistory(query) {
    const history = JSON.parse(localStorage.getItem('searchHistory') || '[]');
    const newHistory = [query, ...history.filter(h => h !== query)].slice(0, 10);
    localStorage.setItem('searchHistory', JSON.stringify(newHistory));
  }

  getSearchHistory() {
    return JSON.parse(localStorage.getItem('searchHistory') || '[]');
  }
}
```

## ğŸ¯ æœ€ä½³å®è·µå»ºè®®

### 1. ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- **é˜²æŠ–æœç´¢**: 300mså»¶è¿Ÿï¼Œé¿å…é¢‘ç¹è¯·æ±‚
- **æ™ºèƒ½æ¨¡å¼**: 1ä¸ªé…æ–™ç”¨ORï¼Œå¤šä¸ªé…æ–™ç”¨AND
- **æœç´¢å»ºè®®**: æ— ç»“æœæ—¶æç¤ºåˆ‡æ¢æ¨¡å¼
- **åŠ è½½çŠ¶æ€**: æ˜¾ç¤ºæœç´¢è¿›åº¦å’Œè€—æ—¶

### 2. æ€§èƒ½ä¼˜åŒ–
- **è¯·æ±‚ç¼“å­˜**: ç¼“å­˜å¸¸ç”¨æœç´¢ç»“æœ
- **è¯·æ±‚å–æ¶ˆ**: é¿å…é‡å¤è¯·æ±‚
- **åˆ†é¡µåŠ è½½**: å¤§é‡ç»“æœæ—¶åˆ†é¡µæ˜¾ç¤º

### 3. ç§»åŠ¨ç«¯é€‚é…
- **è§¦æ‘¸ä¼˜åŒ–**: å¤§æŒ‰é’®ï¼Œæ˜“ç‚¹å‡»
- **ç½‘ç»œä¼˜åŒ–**: è¯·æ±‚å‹ç¼©ï¼Œç¦»çº¿ç¼“å­˜
- **å“åº”å¼è®¾è®¡**: é€‚é…ä¸åŒå±å¹•å°ºå¯¸

ç°åœ¨æ‚¨å¯ä»¥é€‰æ‹©ï¼š

1. **åˆ›å»ºå®Œæ•´çš„å‰ç«¯ç¤ºä¾‹** - æˆ‘å¯ä»¥å¸®æ‚¨åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„HTML+JSæ¼”ç¤ºé¡µé¢
2. **ç‰¹å®šæ¡†æ¶é›†æˆ** - é’ˆå¯¹æ‚¨ä½¿ç”¨çš„å…·ä½“å‰ç«¯æ¡†æ¶ï¼ˆReact/Vue/Angularç­‰ï¼‰æä¾›è¯¦ç»†ä»£ç 
3. **ç§»åŠ¨ç«¯Appé›†æˆ** - å¦‚æœæ˜¯ç§»åŠ¨åº”ç”¨ï¼Œæˆ‘å¯ä»¥æä¾›React Nativeæˆ–Flutterçš„é›†æˆæ–¹æ¡ˆ
4. **APIæ–‡æ¡£å®Œå–„** - åˆ›å»ºè¯¦ç»†çš„APIæ–‡æ¡£ä¾›å‰ç«¯å›¢é˜Ÿä½¿ç”¨

æ‚¨å¸Œæœ›æˆ‘é‡ç‚¹å¸®æ‚¨å®ç°å“ªä¸ªæ–¹é¢å‘¢ï¼Ÿ